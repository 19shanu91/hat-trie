<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>hat-trie: stx::hat_trie&lt; std::string &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">hat-trie
   &#160;<span id="projectnumber">alpha</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>stx</b>      </li>
      <li class="navelem"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html">hat_trie&lt; std::string &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">stx::hat_trie&lt; std::string &gt; Class Template Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="stx::hat_trie&lt; std::string &gt;" -->
<p><code>#include &lt;<a class="el" href="hat__trie_8h_source.html">hat_trie.h</a>&gt;</code></p>

<p><a href="classstx_1_1hat__trie_3_01std_1_1string_01_4-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4_1_1iterator.html">iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the elements in a HAT-trie.  <a href="classstx_1_1hat__trie_3_01std_1_1string_01_4_1_1iterator.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a692e0f968ad287c2e50d95a302ef6793"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::const_iterator" ref="a692e0f968ad287c2e50d95a302ef6793" args="" -->
typedef iterator&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d1a6eb5070c8d35972201d1ebec5c53"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::key_compare" ref="a4d1a6eb5070c8d35972201d1ebec5c53" args="" -->
typedef std::less&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>key_compare</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54d314fffb51911a9c3151b770299356"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::key_type" ref="a54d314fffb51911a9c3151b770299356" args="" -->
typedef std::string&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e6b70e81da96d70e0fcccbcb54b137f"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::size_type" ref="a0e6b70e81da96d70e0fcccbcb54b137f" args="" -->
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fa96d4aeb5017f6f9e22631f5a8e81c"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::value_type" ref="a2fa96d4aeb5017f6f9e22631f5a8e81c" args="" -->
typedef std::string&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#ab97ee11ebfce5424d0f7c15df1f1c63c">hat_trie</a> (const <a class="el" href="classstx_1_1hat__trie__traits.html">hat_trie_traits</a> &amp;traits=<a class="el" href="classstx_1_1hat__trie__traits.html">hat_trie_traits</a>(), const <a class="el" href="classstx_1_1array__hash__traits.html">array_hash_traits</a> &amp;ah_traits=<a class="el" href="classstx_1_1array__hash__traits.html">array_hash_traits</a>())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#a6d7bec16b41a2bb95a3db92276768aa8">hat_trie</a> (const <a class="el" href="classstx_1_1array__hash__traits.html">array_hash_traits</a> &amp;ah_traits)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class input_iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#a6fc6388976f4e5cce440170c5033c3c0">hat_trie</a> (const input_iterator &amp;first, const input_iterator &amp;last, const <a class="el" href="classstx_1_1hat__trie__traits.html">hat_trie_traits</a> &amp;traits=<a class="el" href="classstx_1_1hat__trie__traits.html">hat_trie_traits</a>(), const <a class="el" href="classstx_1_1array__hash__traits.html">array_hash_traits</a> &amp;ah_traits=<a class="el" href="classstx_1_1array__hash__traits.html">array_hash_traits</a>())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#a1aec102686c849f8dba41b1a9c4d4703">begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#a6b0fae0d2917fd6cfb06a9e24659eb94">clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#aa3dd51e55c1e01740a52e7d81d145b10">count</a> (const key_type &amp;word) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#a684fca666da8eeb2d00266d9a177cad0">empty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#a36eceb2097fad63e83f133f3ad285118">end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#a493127c7807f136d5c1cbef5f2d71809">erase</a> (const iterator &amp;pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#af84c3c9095ec72111ee38f866a851fb2">erase</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#a1d754a4c5934261090d9d8923c484cf6">erase</a> (iterator first, const iterator &amp;last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#a3e2f0390b04335ad3eac7c6d2746fcdf">exists</a> (const key_type &amp;word) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#aa76c50032ce6d0971718284c0ca1e84b">find</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstx_1_1array__hash__traits.html">array_hash_traits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#abbff9eb322c91452d9c9275e3a4f478e">hash_traits</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#a908840679a3741ff8c39880a8533acc3">insert</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#a59c6a70b8d5a0f1f177b96485fbcaade">insert</a> (const char *word)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class input_iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#a5c1d229be1b55222fb0c29493d3fb75d">insert</a> (input_iterator first, const input_iterator &amp;last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#ae2ac2e385072f8f2c79f8fa7d2b1194c">insert</a> (const iterator &amp;, const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#ab183516b0d6fa02289781f9e7779e3d9">print</a> (std::ostream &amp;out=std::cout) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#ab3bd7f9b2bbc1702e403957f6eb1171b">size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#a370ffa92c898bd1607f24ddf30ce7205">swap</a> (hat_trie &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstx_1_1hat__trie__traits.html">hat_trie_traits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#a80fe3df755fd883eeeba16e76fd650d1">traits</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a92289043fbe1d4d5a8fbf251606c1c6a"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::operator!=" ref="a92289043fbe1d4d5a8fbf251606c1c6a" args="(const hat_trie&lt; F &gt; &amp;lhs, const hat_trie&lt; F &gt; &amp;rhs)" -->
template&lt;class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const hat_trie&lt; F &gt; &amp;lhs, const hat_trie&lt; F &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a884af3a91406b833ea14b58245608973"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::operator&lt;" ref="a884af3a91406b833ea14b58245608973" args="(const hat_trie&lt; F &gt; &amp;lhs, const hat_trie&lt; F &gt; &amp;rhs)" -->
template&lt;class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const hat_trie&lt; F &gt; &amp;lhs, const hat_trie&lt; F &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="afe973e870c1493b26d42ef4a7f210b82"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::operator&lt;=" ref="afe973e870c1493b26d42ef4a7f210b82" args="(const hat_trie&lt; F &gt; &amp;lhs, const hat_trie&lt; F &gt; &amp;rhs)" -->
template&lt;class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const hat_trie&lt; F &gt; &amp;lhs, const hat_trie&lt; F &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a66bdbd7d11c12dfc46eb969d5dc6110f"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::operator==" ref="a66bdbd7d11c12dfc46eb969d5dc6110f" args="(const hat_trie&lt; F &gt; &amp;lhs, const hat_trie&lt; F &gt; &amp;rhs)" -->
template&lt;class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const hat_trie&lt; F &gt; &amp;lhs, const hat_trie&lt; F &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a40abac7acee3e1355d2c7a5de8dca3d0"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::operator&gt;" ref="a40abac7acee3e1355d2c7a5de8dca3d0" args="(const hat_trie&lt; F &gt; &amp;lhs, const hat_trie&lt; F &gt; &amp;rhs)" -->
template&lt;class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const hat_trie&lt; F &gt; &amp;lhs, const hat_trie&lt; F &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a24add44a77f5189ea64d9282337d3a75"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::operator&gt;=" ref="a24add44a77f5189ea64d9282337d3a75" args="(const hat_trie&lt; F &gt; &amp;lhs, const hat_trie&lt; F &gt; &amp;rhs)" -->
template&lt;class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const hat_trie&lt; F &gt; &amp;lhs, const hat_trie&lt; F &gt; &amp;rhs)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;&gt;<br/>
class stx::hat_trie&lt; std::string &gt;</h3>

<p>Trie-based data structure for managing sorted strings. Don't use this class directly. Use hat_set or hat_map </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab97ee11ebfce5424d0f7c15df1f1c63c"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::hat_trie" ref="ab97ee11ebfce5424d0f7c15df1f1c63c" args="(const hat_trie_traits &amp;traits=hat_trie_traits(), const array_hash_traits &amp;ah_traits=array_hash_traits())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stx::hat_trie&lt; std::string &gt;::hat_trie </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1hat__trie__traits.html">hat_trie_traits</a> &amp;&#160;</td>
          <td class="paramname"><em>traits</em> = <code><a class="el" href="classstx_1_1hat__trie__traits.html">hat_trie_traits</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstx_1_1array__hash__traits.html">array_hash_traits</a> &amp;&#160;</td>
          <td class="paramname"><em>ah_traits</em> = <code><a class="el" href="classstx_1_1array__hash__traits.html">array_hash_traits</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default constructor. </p>

</div>
</div>
<a class="anchor" id="a6d7bec16b41a2bb95a3db92276768aa8"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::hat_trie" ref="a6d7bec16b41a2bb95a3db92276768aa8" args="(const array_hash_traits &amp;ah_traits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stx::hat_trie&lt; std::string &gt;::hat_trie </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1array__hash__traits.html">array_hash_traits</a> &amp;&#160;</td>
          <td class="paramname"><em>ah_traits</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Array hash traits constructor. </p>

</div>
</div>
<a class="anchor" id="a6fc6388976f4e5cce440170c5033c3c0"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::hat_trie" ref="a6fc6388976f4e5cce440170c5033c3c0" args="(const input_iterator &amp;first, const input_iterator &amp;last, const hat_trie_traits &amp;traits=hat_trie_traits(), const array_hash_traits &amp;ah_traits=array_hash_traits())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class input_iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">stx::hat_trie&lt; std::string &gt;::hat_trie </td>
          <td>(</td>
          <td class="paramtype">const input_iterator &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const input_iterator &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstx_1_1hat__trie__traits.html">hat_trie_traits</a> &amp;&#160;</td>
          <td class="paramname"><em>traits</em> = <code><a class="el" href="classstx_1_1hat__trie__traits.html">hat_trie_traits</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstx_1_1array__hash__traits.html">array_hash_traits</a> &amp;&#160;</td>
          <td class="paramname"><em>ah_traits</em> = <code><a class="el" href="classstx_1_1array__hash__traits.html">array_hash_traits</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Builds a HAT-trie from the data in [first, last).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>iterators specifying a range of elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1aec102686c849f8dba41b1a9c4d4703"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::begin" ref="a1aec102686c849f8dba41b1a9c4d4703" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iterator stx::hat_trie&lt; std::string &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets an iterator to the first element in the trie.</p>
<p>If there are no elements in the trie, the iterator pointing to trie.end() is returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>iterator to the first element in the trie </dd></dl>

</div>
</div>
<a class="anchor" id="a6b0fae0d2917fd6cfb06a9e24659eb94"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::clear" ref="a6b0fae0d2917fd6cfb06a9e24659eb94" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stx::hat_trie&lt; std::string &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes all the elements in the trie. </p>

</div>
</div>
<a class="anchor" id="aa3dd51e55c1e01740a52e7d81d145b10"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::count" ref="aa3dd51e55c1e01740a52e7d81d145b10" args="(const key_type &amp;word) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_type stx::hat_trie&lt; std::string &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Counts the number of times a word appears in the trie.</p>
<p>In distinct containers, this number will either be 1 or 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>word to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of times <em>word</em> appears in the trie </dd></dl>

</div>
</div>
<a class="anchor" id="a684fca666da8eeb2d00266d9a177cad0"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::empty" ref="a684fca666da8eeb2d00266d9a177cad0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stx::hat_trie&lt; std::string &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines whether this container is empty.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true iff this container has no data </dd></dl>

</div>
</div>
<a class="anchor" id="a36eceb2097fad63e83f133f3ad285118"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::end" ref="a36eceb2097fad63e83f133f3ad285118" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iterator stx::hat_trie&lt; std::string &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets an iterator to one past the last element in the trie.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>iterator to one past the last element in the trie </dd></dl>

</div>
</div>
<a class="anchor" id="a493127c7807f136d5c1cbef5f2d71809"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::erase" ref="a493127c7807f136d5c1cbef5f2d71809" args="(const iterator &amp;pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stx::hat_trie&lt; std::string &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const iterator &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erases a word from the trie.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>iterator to the word in the trie. Must point to a word that exists somewhere in the trie. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af84c3c9095ec72111ee38f866a851fb2"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::erase" ref="af84c3c9095ec72111ee38f866a851fb2" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_type stx::hat_trie&lt; std::string &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erases a word from the trie.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>word to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of words erased from the trie. In a distinct container, either 1 if the word was removed from the trie or 0 if the word doesn't appear in the trie </dd></dl>

</div>
</div>
<a class="anchor" id="a1d754a4c5934261090d9d8923c484cf6"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::erase" ref="a1d754a4c5934261090d9d8923c484cf6" args="(iterator first, const iterator &amp;last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stx::hat_trie&lt; std::string &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iterator &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erases several words from the trie.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>iterators specifying a range of words to remove from the trie. All words in the range [first, last) are removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e2f0390b04335ad3eac7c6d2746fcdf"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::exists" ref="a3e2f0390b04335ad3eac7c6d2746fcdf" args="(const key_type &amp;word) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stx::hat_trie&lt; std::string &gt;::exists </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Searches for a word in the trie.</p>
<p>This function is an extension to the standard STL interface.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>word to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true iff <em>s</em> is in the trie </dd></dl>

</div>
</div>
<a class="anchor" id="aa76c50032ce6d0971718284c0ca1e84b"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::find" ref="aa76c50032ce6d0971718284c0ca1e84b" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iterator stx::hat_trie&lt; std::string &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Searches for <em>s</em> in the trie.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>word to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>iterator to <em>s</em> in the trie. If <em>s</em> is not in the trie, returns an iterator to one past the last element </dd></dl>

</div>
</div>
<a class="anchor" id="abbff9eb322c91452d9c9275e3a4f478e"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::hash_traits" ref="abbff9eb322c91452d9c9275e3a4f478e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstx_1_1array__hash__traits.html">array_hash_traits</a>&amp; stx::hat_trie&lt; std::string &gt;::hash_traits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the array hash traits associated with the hash tables in this trie. </p>

</div>
</div>
<a class="anchor" id="a908840679a3741ff8c39880a8533acc3"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::insert" ref="a908840679a3741ff8c39880a8533acc3" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stx::hat_trie&lt; std::string &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a word into the trie.</p>
<p>According to the standard, this function should return a pair&lt;iterator, bool&gt; rather than just a bool. The lack of a pair returning insert function is intentional because a pair returning insert takes twice as long as the bool version implemented now. The slowdown is significant enough to make insertion time comparable to an STL set (red-black tree), whuch is unacceptable for a high-performance data structure like a HAT-trie. Calling <a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#a908840679a3741ff8c39880a8533acc3">insert()</a> then <a class="el" href="classstx_1_1hat__trie_3_01std_1_1string_01_4.html#aa76c50032ce6d0971718284c0ca1e84b">find()</a> is the intended solution.</p>
<p>I consider this acceptable because iterators are unstable. Like STL iterators, HAT-trie iterators are invalidated on any call to insert or erase because memory may be rearranged by a burst operation. Additionally, in a typical scenario, keys aren't operated on as they are inserted. Insertion and operation occur in two different passes, meaning any iterators collected during the insertion pass would be invalidated by the start of the operation pass anyway.</p>
<p>Feel free to notify me if you disagree.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>word to insert</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if <em>word</em> is inserted into the trie, false if <em>word</em> was already in the trie </dd></dl>

</div>
</div>
<a class="anchor" id="a59c6a70b8d5a0f1f177b96485fbcaade"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::insert" ref="a59c6a70b8d5a0f1f177b96485fbcaade" args="(const char *word)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stx::hat_trie&lt; std::string &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a word into the trie.</p>
<p>Uses C-strings instead of C++ strings. This function is no more efficient than the string version. It is provided for convenience.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>word to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if <em>word</em> is inserted into the trie, false if <em>word</em> was already in the trie </dd></dl>

</div>
</div>
<a class="anchor" id="a5c1d229be1b55222fb0c29493d3fb75d"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::insert" ref="a5c1d229be1b55222fb0c29493d3fb75d" args="(input_iterator first, const input_iterator &amp;last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class input_iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stx::hat_trie&lt; std::string &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">input_iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const input_iterator &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts several words into the trie.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>iterators specifying a range of words to add to the trie. All words in the range [first, last) are added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2ac2e385072f8f2c79f8fa7d2b1194c"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::insert" ref="ae2ac2e385072f8f2c79f8fa7d2b1194c" args="(const iterator &amp;, const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iterator stx::hat_trie&lt; std::string &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const iterator &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts several words into the trie.</p>
<p>In standard STL sets, this function can dramatically increase performance if the iterator is set correctly. This performance gain is unachievable in a HAT-trie because the time required to verify that the iterator points to the right place is just as expensive as a regular insert operation. This function is provided to meet the standard, but that's about it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>word to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>iterator to <em>word</em> in the trie </dd></dl>

</div>
</div>
<a class="anchor" id="ab183516b0d6fa02289781f9e7779e3d9"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::print" ref="ab183516b0d6fa02289781f9e7779e3d9" args="(std::ostream &amp;out=std::cout) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stx::hat_trie&lt; std::string &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints the hierarchical structure of the trie.</p>
<p>The output is indented to indicate trie depth. Words are marked by a ~, and containers are marked by a *. For example, a trie with a <em>burst_threshold</em> of 2 with the words the, their, there, they're, train, trust, truth, bear, and breath would produce this output:</p>
<p>b * reath ~ ear ~ t h e ~ r * e ~ y * `re ~ i * r ~ r a * in ~ u * st ~ th ~</p>
<p>(This isn't exactly right because of the particular bursting algorithm this implementation uses, but it is a good example.)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output stream to print to. cout by default </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3bd7f9b2bbc1702e403957f6eb1171b"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::size" ref="ab3bd7f9b2bbc1702e403957f6eb1171b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_type stx::hat_trie&lt; std::string &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the number of distinct elements in the trie.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>size of the trie </dd></dl>

</div>
</div>
<a class="anchor" id="a370ffa92c898bd1607f24ddf30ce7205"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::swap" ref="a370ffa92c898bd1607f24ddf30ce7205" args="(hat_trie &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stx::hat_trie&lt; std::string &gt;::swap </td>
          <td>(</td>
          <td class="paramtype">hat_trie&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swaps the data in two hat_trie objects.</p>
<p>This function operates in constant time because all it needs to do is swap a few primitives.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>hat_trie object to swap data with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80fe3df755fd883eeeba16e76fd650d1"></a><!-- doxytag: member="stx::hat_trie&lt; std::string &gt;::traits" ref="a80fe3df755fd883eeeba16e76fd650d1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstx_1_1hat__trie__traits.html">hat_trie_traits</a>&amp; stx::hat_trie&lt; std::string &gt;::traits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the traits associated with this trie. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="hat__trie_8h_source.html">hat_trie.h</a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 2 2012 21:28:27 for hat-trie by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
